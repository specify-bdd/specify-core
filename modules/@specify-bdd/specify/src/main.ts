#!/usr/bin/env node

/**
 * Core Module
 *
 * A Cucumber-based testing tool built to support behavior-driven development.
 */

import { Command as App   } from "commander"; // aliased to avoid confusion with our XCommand classes
import merge                from "deepmerge";
import { error, log       } from "node:console";
import path                 from "node:path";
import util                 from "node:util";
import { deserializeError } from "serialize-error";

import { config                            } from "@/config/all";
import { CommandResult                     } from "./lib/Command";
import { TestCommand, TestCommandArguments } from "./lib/TestCommand";
import { TestCommandWatcher                } from "./lib/TestCommandWatcher";
import npmPackage                            from "../package.json" with { "type": "json" };

import { parseParallelOption, parseRerunFileOption, parseRetryOption } from "./lib/cli-parsers";

let cucumberCfg = config.cucumber;

// resolve plugins
for (const plugin of config.plugins) {
    const mod = await import(plugin);

    for (const prop in mod.default) {
        switch (prop) {
            case "cucumber":
                cucumberCfg = merge.all([{}, mod.default.cucumber, cucumberCfg]);
                break;
        }
    }
}

// add core cucumber support code path
cucumberCfg.import ??= [];
cucumberCfg.import.push(path.resolve(import.meta.dirname, "cucumber"));

// build CLI app behavior
const app      = new App();
const helpText = config.content.help.specify;

app.name("specify")
    .description(npmPackage.description)
    .version(npmPackage.version, "-v, --version", helpText.options.version)
    .helpCommand("help [command]", helpText.commands.help)
    .helpOption("-h, --help", helpText.options.help);

app.exitOverride(() => process.exit(2))
    .command("test", { "isDefault": true })
    .summary(helpText.commands.test.summary)
    .description(helpText.commands.test.description)
    .argument("[paths...]", helpText.commands.test.arguments.paths)
    .helpOption("-h, --help", helpText.commands.test.options.help)
    .option("--rerun", helpText.commands.test.options.rerun)
    .option(
        "--rerun-file <path>",
        util.format(helpText.commands.test.options.rerunFile, config.paths.rerun),
        parseRerunFileOption,
        config.paths.rerun,
    )
    .option(
        "-r, --retry <number_of_retries>",
        util.format(helpText.commands.test.options.retry, cucumberCfg.retry),
        parseRetryOption,
    )
    .option(
        "-R, --retry-tag <tags>",
        util.format(helpText.commands.test.options.retryTag, cucumberCfg.retryTagFilter),
    )
    .option("-t, --tags <tags>", helpText.commands.test.options.tags)
    .option(
        "-p, --parallel <number_of_workers>",
        helpText.commands.test.options.parallel,
        parseParallelOption,
    )
    .option("-w, --watch", helpText.commands.test.options.watch)
    .action(runTests);

// process args and execute commands
await app.parseAsync();

/**
 * Report errors generated by command actions and terminate the process.
 *
 * @param res - The command result to parse
 */
function reportAndExit(res: CommandResult): void {
    if (res.error) {
        error(res.debug ? deserializeError(res.error) : deserializeError(res.error).message);
    }

    process.exit(res.status);
}

/**
 * Run tests and report the results.
 *
 * @param paths - The behavior spec file paths
 * @param opts  - The CLI options used
 */
async function runTests(paths: string[], opts: TestCommandArguments = {}): Promise<void> {
    const cmd = new TestCommand({
        "cucumber":     cucumberCfg,
        "debug":        config.debug,
        "gherkinPaths": [path.resolve(config.paths.gherkin)],
        "logPath":      path.resolve(config.paths.logs, `specify-test-log-${Date.now()}.json`),
    });

    const args = merge({ paths }, opts) as TestCommandArguments;

    if (args.watch) {
        if (args.rerun) {
            log("Conflicting options: --rerun cannot be used with --watch");
            process.exit(2);
        }

        const watcher = new TestCommandWatcher(cmd);

        await watcher.start(args);

        return;
    }

    return cmd.execute(args).then(reportAndExit);
}
